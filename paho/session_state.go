package paho

import (
	"context"
	"fmt"
	"io"
	"sync"

	"github.com/eclipse/paho.golang/packets"
)

// The Session State, as per the MQTT spec, contains:
//
//	QoS 1 and QoS 2 messages which have been sent to the Server, but have not been completely acknowledged.
//	QoS 2 messages which have been received from the Server, but have not been completely acknowledged.
//
// Messages in the state will be identified by their packet identifier (generated by us for outgoing packets and
// received from the server for inbound). It is important to note that there are packets with identifiers that do
// not form part of the session state (SUBSCRIBE, SUBACK, UNSUBSCRIBE, UNSUBACK). Whilst subscriptions are not part of
// the client state they are included in the server state which means we may receive new messages when a connection is
// established that were stored in the server state. Message identifiers will managed within the sessionState struct
// because they may outlast a `paho.Client` and we want this to be invisible to the end user. TODO: Reword
// NONONONO - Sending a PUBREC to an old `client` will be a problem (it will respond to the wrong connection). We need
// to be able to transfer them somehow.... Should the ACK process be managed within this struct??
//
// The following packets influence the client state:
//   * CONNECT - If the  Clean Start flag is set then we should fully clear the session (explict user request).
//   * CONNACK - The Session Present flag indicates whether the server has knowledge of a session. If there is no
//               session present, we need to clear our session (TODO: perhaps resending unacknowledged PUBLISH packets)
//   * PUBLISH (If QoS > 0) - New entry in the state
//   * PUBACK response to a QOS1 PUBLISH; completes the QOS1 acknowledgment process.
//   * PUBREC response to a QOS2 PUBLISH; acknowledges receipt of the message.
//   * PUBREL response to a PUBREC; confirms that the original message will not be re-transmitted.
//   * PUBCOMP response to a PUBREL; completes the QOS2 acknowledgment process.
//
// TODO: How to deal with connecting to multiple brokers/changing the client id... (something for autopaho to sort out!)
// Paho provides notification when relevant packets (PUBLISH, PUBACK, PUBREC, PUBREL, PUBCOMP) are sent/received
// to allow the state to be updated.
// type Persistence interface {
// 	// Sending will be called prior to a relevant packet being sent (or would have sent a packet had an error not occurred).
// 	// Will not be called when an error response is being sent (e.g. received a packet but have no record of the ID).
// 	Sending(StatePacket) error
//
// 	// Received will be called when a relevant packet is received from the server
// 	Received(StatePacket) error
// }

// Why integrate MIDs?
//
// Main reason is tht the session state may outlast a single connection and it should be possible for `Publish` calls
// to continue to block across a reconnection. In addition:
//   * Loading ID's may be expensive and by controlling it here we allow alternate strategies (for instance retrieving the
//     ids and state rather than full packets when starting up).
//

// StatePacket provides information on a packet to be stored in the session state
type StatePacket interface {
	Type() byte // Returns the packet type (as per section 2.1.2 of the MQTT v5 spec)
	ID() uint16 // Returns the ID assigned to the packet (must be non-zero)
	io.WriterTo // Permits the packet to be written
}

// sessionState manages the session state. The client will send messages that may impact the state via
// us and we will maintain the session state
type sessionState struct {
	SessionExpiryInterval *uint32 // The session expiry interval sent with the most recent CONNECT packet

	MIDs MIDService // Don't really want this because we can implement the interface ourself...
	// server store - holds packets where the message ID was generated on the server
	serverMu      sync.RWMutex
	serverPackets map[uint16]StatePacket // Holds messages initiated by the server (i.e. we will receive the PUBLISH)

	// client store - holds packets where the message ID was generated on the client (i.e. by paho.golang)
	clientMu      sync.RWMutex
	clientPackets map[uint16]StatePacket // Store relating to messages sent TO the server

	debug  Logger
	errors Logger
}

func (s *sessionState) setIdentifierAndSend(packet packetWithID, cpCtx *CPContext) error {
	mid, err := s.MIDs.Request(cpCtx)
	if err != nil {
		return err
	}
	packet.SetIdentifier(mid)
	if _, err := packet.WriteTo(c.Conn); err != nil {
		// Should we clear error in this case? Probably not as it should be in store
		return err
	}
	return nil
}

func (s *sessionState) sendViaStore(packet packets.Packet, cpCtx *CPContext) {

}

// Acknowledge is called when an acknowledgment (PUBACK, PUBREC, PUBCOMP, SUBACK, UNSUBACK),
// of something we initially sent, is received. The session state
func (s *sessionState) Acknowledge(packet packetWithID, cpCtx *CPContext, conn io.Writer) {

}

// Sending will be called prior to a packet being sent to the server (to update session state)
func (s *sessionState) Sending(cp StatePacket) error {
	packetID := cp.ID()

	switch cp.Type() {
	case packets.PUBLISH: // Client publishing
		s.clientMu.Lock()
		defer s.clientMu.Unlock()
		if _, ok := s.clientPackets[packetID]; ok {
			return ErrPacketIdInUse // Should not happen (this is an issue with the local state)
		}
		s.clientPackets[packetID] = cp
		return nil
	case packets.PUBACK, packets.PUBCOMP: // Sending final acknowledgement of PUBLISH received from the server
		s.serverMu.Lock()
		defer s.serverMu.Unlock()
		if _, ok := s.serverPackets[packetID]; !ok {
			return ErrPacketIdNotFound // Should not happen (this is an issue with the local state)
		}
		delete(s.serverPackets, packetID) // Message fully acknowledged so transaction complete
		return nil
	case packets.PUBREC: // We are acknowledging receipt of a QOS2 PUBLISH received from the server
		s.serverMu.Lock()
		defer s.serverMu.Unlock()
		if _, ok := s.serverPackets[packetID]; !ok {
			return ErrPacketIdNotFound // Should not happen (this is an issue with the local state)
		}
		s.serverPackets[packetID] = cp
		return nil
	case packets.PUBREL: // Releasing a QOS2 publish we originally sent
		// The PUBREL will only be sent after any handlers have run.
		// We need to store this so that the message is not sent for processing a second time (only applies to manual ACK).
		s.clientMu.Lock()
		defer s.clientMu.Unlock()
		if _, ok := s.clientPackets[packetID]; !ok {
			return ErrPacketIdNotFound // Should not happen (this is an issue with the local state)
		}
		s.clientPackets[packetID] = cp
		return nil
	}
	return ErrUnsupportedPacketType
}

// ReceivedPublish called when a PUBLISH packet is received. Returns the Publish message to be sent to the user (if
// any) and an error (errors should result in the connection being dropped)
func (s *sessionState) ReceivedPublish(flags byte, p packets.Publish) (*packets.Publish, error) {

}

func (s *sessionState) ReceivedPubAck(flags byte, p packets.Puback) error {

}



func (s *sessionState) Received(ctx context.Context, cp *packets.ControlPacket,  publish chan<- *packets.Publish, sendResponse func(packets.Packet) error) error {
	packetID := cp.ID()
	// TODO: Check reason codes (because for some packets they may indicate that
	switch recv := cp.Content.(type) {
	case *packets.Publish: // Incoming publish from server
		// If there is already something in the store with this ID then that may mean that this is a duplicate
		// (so should not be passed to the client).
		s.serverMu.Lock()
		defer s.serverMu.Unlock()
		if _, ok := s.serverPackets[packetID]; ok {
			return ErrPacketIdInUse // Should not happen (this is an issue with the local state)
		}
		s.serverPackets[packetID] = cp
		return nil
	case packets.PUBACK, packets.PUBCOMP: // Receiving the final acknowledgement of PUBLISH we sent
		s.clientMu.Lock()
		defer s.clientMu.Unlock()
		if _, ok := s.clientPackets[packetID]; !ok {
			return ErrPacketIdNotFound // Should not happen (as packetID will not be in MIDS)
		}
		delete(s.clientPackets, packetID) // Message fully acknowledged so transaction complete
		return nil
	case *packets.Pubrec: // Initial acknowledgement of a QOS2 publish we sent
		s.debug.Println("received PUBREC for", recv.PacketID)
		s.clientMu.Lock()
		defer s.clientMu.Unlock()
		if _, ok := s.clientPackets[packetID]; !ok {
			s.debug.Println("received a PUBREC for a message ID we don't know:", recv.PacketID)
			pl := packets.Pubrel{
				PacketID:   recv.PacketID,
				ReasonCode: 0x92,
			}
			s.debug.Println("sending PUBREL for", pl.PacketID)
			if err :=sendResponse(&pl); err != nil {
				s.errors.Printf("failed to send 0x92 PUBREL for %d: %s", pl.PacketID, err)
			}
			return ErrPacketIdNotFound // Should not happen (as packetID will not be in MIDS)
		}
		pr := recv.Content.(*packets.Pubrec)
		if pr.ReasonCode >= 0x80 {
			// Received a failure code, shortcut and return
			cpCtx.Return <- *recv
		} else {
			pl := packets.Pubrel{
				PacketID: pr.PacketID,
			}
			s.debug.Println("sending PUBREL for", pl.PacketID)
			_, err := pl.WriteTo(c.Conn)
			if err != nil {
				s.errors.Printf("failed to send PUBREL for %d: %s", pl.PacketID, err)
			}
		}
		// No need to record this (store will be updated when the PUBREL is sent)
		return nil
		s.debug.Println("received PUBREC for", recv.PacketID())
		if cpCtx := s.MIDs.Get(recv.PacketID()); cpCtx == nil {
			s.debug.Println("received a PUBREC for a message ID we don't know:", recv.PacketID())
			pl := packets.Pubrel{
				PacketID:   recv.Content.(*packets.Pubrec).PacketID,
				ReasonCode: 0x92,
			}
			s.debug.Println("sending PUBREL for", pl.PacketID)
			_, err := pl.WriteTo(c.Conn)
			if err != nil {
				s.errors.Printf("failed to send PUBREL for %d: %s", pl.PacketID, err)
			}
		} else {
			pr := recv.Content.(*packets.Pubrec)
			if pr.ReasonCode >= 0x80 {
				// Received a failure code, shortcut and return
				cpCtx.Return <- *recv
			} else {
				pl := packets.Pubrel{
					PacketID: pr.PacketID,
				}
				s.debug.Println("sending PUBREL for", pl.PacketID)
				_, err := pl.WriteTo(c.Conn)
				if err != nil {
					s.errors.Printf("failed to send PUBREL for %d: %s", pl.PacketID, err)
				}
			}
		}

	case packets.PUBREL: // Server has received the PUBREC we sent re QOS2 publish server sent
		s.serverMu.Lock()
		defer s.serverMu.Unlock()
		if _, ok := s.serverPackets[packetID]; !ok {
			return ErrPacketIdNotFound // Should not happen (this is an issue with the local state)
		}
		// No need to record this (store will be updated when the PUBCOMP is sent because it should be sent immediatly)
		return nil
	}
	return ErrUnsupportedPacketType
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// type sender interface {
// 	WriteFrom(from io.ReaderFrom)
// }

// ConAckReceived will be called when the client receives a CONACK. This indicates that a new connection is live
// and the passed in connection should be used going forward. It is also the trigger to resend any queued messages.
func (s *sessionState) ConAckReceived(cp *packets.Connect, ca *packets.Connack, conn io.Writer) error {
	// We could use cp.Properties.SessionExpiryInterval /  ca.Properties.SessionExpiryInterval to clear the session
	// after the specified time period (if the Session Expiry Interval is absent the value in the CONNECT Packet used)
	// however, this is not something the generic client can really accomplish (forks may wish to do this!).

	if s.SessionExpiryInterval == nil ||

	s.SessionExpiryInterval = nil

	s.SessionExpiryInterval = ca.Properties.SessionExpiryInterval
}

// PublishReceived called when a publish packet is received; if an error is returned the packet should not
// be processed further.
func (s *sessionState) PublishReceived(pb *packets.Publish) error {
	// TODO: Check that we don't already have publish with this id (and if not add to the store)
}

func (s *sessionState) PubAckReceived(pa *packets.Puback) error {
	s.debug.Printf("received %s packet with id %d", recv.PacketType(), recv.PacketID())
	if cpCtx := s.MIDs.Get(recv.PacketID()); cpCtx != nil {
		cpCtx.Return <- pa
	} else {
		s.debug.Println("received a response for a message ID we don't know:", recv.PacketID())
	}
	return nil
}

// finalAckReceived called when a transaction is complete and should be removed from the store
func (s *sessionState) finalAckReceived(packetIdentifier uint32) error {

}

// passed CONNACK, PUBLISH, PUBACK, PUBCOMP, SUBACK, UNSUBACK,  PUBREC,
// PUBREL and DISCONNECT
// Returns an error if the connection should be dropped
func (s *sessionState) packetReceived(recv *packets.ControlPacket, response packets.Packet) error {
	switch recv.Type {
	case packets.CONNACK:
		s.debug.Println("received CONNACK")
		return fmt.Errorf("received unexpected CONNACK")
	case packets.PUBLISH:
		pb := recv.Content.(*packets.Publish)
		s.debug.Printf("received QoS%d PUBLISH", pb.QoS)
		c.mu.Lock()
		select {
		case <-c.stop:
			c.mu.Unlock()
			return
		default:
			c.publishPackets <- pb
			c.mu.Unlock()
		}
	case packets.PUBACK, packets.PUBCOMP, packets.SUBACK, packets.UNSUBACK:
		s.debug.Printf("received %s packet with id %d", recv.PacketType(), recv.PacketID())
		if cpCtx := s.MIDs.Get(recv.PacketID()); cpCtx != nil {
			cpCtx.Return <- *recv
		} else {
			s.debug.Println("received a response for a message ID we don't know:", recv.PacketID())
		}
	case packets.PUBREC:
		s.debug.Println("received PUBREC for", recv.PacketID())
		if cpCtx := s.MIDs.Get(recv.PacketID()); cpCtx == nil {
			s.debug.Println("received a PUBREC for a message ID we don't know:", recv.PacketID())
			pl := packets.Pubrel{
				PacketID:   recv.Content.(*packets.Pubrec).PacketID,
				ReasonCode: 0x92,
			}
			s.debug.Println("sending PUBREL for", pl.PacketID)
			_, err := pl.WriteTo(c.Conn)
			if err != nil {
				s.errors.Printf("failed to send PUBREL for %d: %s", pl.PacketID, err)
			}
		} else {
			pr := recv.Content.(*packets.Pubrec)
			if pr.ReasonCode >= 0x80 {
				// Received a failure code, shortcut and return
				cpCtx.Return <- *recv
			} else {
				pl := packets.Pubrel{
					PacketID: pr.PacketID,
				}
				s.debug.Println("sending PUBREL for", pl.PacketID)
				_, err := pl.WriteTo(c.Conn)
				if err != nil {
					s.errors.Printf("failed to send PUBREL for %d: %s", pl.PacketID, err)
				}
			}
		}
	case packets.PUBREL:
		s.debug.Println("received PUBREL for", recv.PacketID())
		// Auto respond to pubrels unless failure code
		pr := recv.Content.(*packets.Pubrel)
		if pr.ReasonCode >= 0x80 {
			// Received a failure code, continue
			continue
		} else {
			pc := packets.Pubcomp{
				PacketID: pr.PacketID,
			}
			s.debug.Println("sending PUBCOMP for", pr.PacketID)
			_, err := pc.WriteTo(c.Conn)
			if err != nil {
				s.errors.Printf("failed to send PUBCOMP for %d: %s", pc.PacketID, err)
			}
		}
	case packets.DISCONNECT:
		s.debug.Println("received DISCONNECT")
		if c.raCtx != nil {
			c.raCtx.Return <- *recv
		}
		go func() {
			if c.OnServerDisconnect != nil {
				go c.serverDisconnect(DisconnectFromPacketDisconnect(recv.Content.(*packets.Disconnect)))
			} else {
				return fmt.Errorf("server initiated disconnect")
			}
		}()
		return
	case packets.PINGRESP:
		s.debug.Println("received PINGRESP")
		c.PingHandler.PingResp()
	}
}

// FreeMessageIdentifier frees a message identifier, generated by us, for reuse. The packet that triggered the request
// should be passed in; this may be used in the future to confirm that the request is valid (i.e. a SUBACK should only
// free an identifier created due to a SUBSCRIBE request).
func (s *sessionState) FreeMessageIdentifier(id uint16, trigger packets.Packet) error {
	return nil
}

/*
type MIDService interface {
	Request(*CPContext) (uint16, error)
	Get(uint16) *CPContext
	Free(uint16)
	Clear()
*/
