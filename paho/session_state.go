package paho

import (
	"errors"
	"fmt"
	"io"
	"sync"
	"time"

	"github.com/eclipse/paho.golang/packets"
)

// The Session State, as per the MQTT spec, contains:
//
//	> QoS 1 and QoS 2 messages which have been sent to the Server, but have not been completely acknowledged.
//	> QoS 2 messages which have been received from the Server, but have not been completely acknowledged.
//
// and, importantly is used when resending as follows:
//
// > When a Client reconnects with Clean Start set to 0 and a session is present, both the Client and Server MUST resend
// > any unacknowledged PUBLISH packets (where QoS > 0) and PUBREL packets using their original Packet Identifiers. This
// > is the only circumstance where a Client or Server is REQUIRED to resend messages. Clients and Servers MUST NOT
// > resend messages at any other time
//
// While not strictly part of the session state, Message IDs are linked because when we reconnect the message IDs of any
// packets that remain in the state must remain live (or be allocated if we are loading state from storage). Because of
// the fact that Message ID allocation may outlast the connection it makes sense to manage these with the state.
//
// This means that the following information may need to be retained after the connection is lost:
//  * The IDs of any transactions initiated by the client (so that we don't reuse IDs and can notify the requester (if
//    known) when a response is received or the request is removed from the state).
//  * For client initiated publish:
//     * Outgoing `PUBLISH` packets to allow resend.
//     * Outgoing `PUBREL` packets to allow resend.
//  * For server initiated publish:
//     * Outgoing `PUBREL` packets. The fact that this has been sent indicates that the user app has acknowledged the
//       message and it should not be re-presented (doing so would breach the "exactly once" requirement).
//     * In memory only - the fact that a QOS2 PUBLISH has been received and sent to the handler, but not acknowledged.
//       This allows us to avoid presenting the message a second time (if the application is restarted we have no option
//       but to represent it because we have no way of knowing if the application completed handling it).
//
// While the connection is up we will need, in addition to the above, information on all client initiated transactions
// (to avoid message ID reuse and so we know who to advise when a response is received).
//

// Messages in the state will be identified by their packet identifier (generated by us for outgoing packets and
// received from the server for inbound). It is important to note that there are packets with identifiers that do
// not form part of the session state (SUBSCRIBE, SUBACK, UNSUBSCRIBE, UNSUBACK). Whilst subscriptions are not part of
// the client state they are included in the server state which means we may receive new messages when a connection is
// established that were stored in the server state. Message identifiers will managed within the sessionState struct
// because they may outlast a `paho.Client` and we want this to be invisible to the end user. TODO: Reword
// NONONONO - Sending a PUBREC to an old `client` will be a problem (it will respond to the wrong connection). We need
// to be able to transfer them somehow.... Should the ACK process be managed within this struct??
//
// The following packets influence the client state:
//   * CONNECT - If the  Clean Start flag is set then we should fully clear the session (explict user request).
//   * CONNACK - The Session Present flag indicates whether the server has knowledge of a session. If there is no
//               session present, we need to clear our session (TODO: perhaps resending unacknowledged PUBLISH packets)
//   * PUBLISH (If QoS > 0) - New entry in the state
//   * PUBACK response to a QOS1 PUBLISH; completes the QOS1 acknowledgment process.
//   * PUBREC response to a QOS2 PUBLISH; acknowledges receipt of the message.
//   * PUBREL response to a PUBREC; confirms that the original message will not be re-transmitted.
//   * PUBCOMP response to a PUBREL; completes the QOS2 acknowledgment process.
//
// What is stored?
//
// We only need to store things that might be needed; the spec states:
//
// > When a Client reconnects with Clean Start set to 0 and a session is present, both the Client and Server MUST resend
// > any unacknowledged PUBLISH packets (where QoS > 0) and PUBREL packets using their original Packet Identifiers. This
// > is the only circumstance where a Client or Server is REQUIRED to resend messages. Clients and Servers MUST NOT
// > resend messages at any other time
//
// So the only thing we need to resend (and hence, store) are QOS1+ PUBLISH and PUBREL packets that we are sending. We
// do NOT need to store any received packets because the broker will resend them (but we do need to know the state of
// QOS2 transactions so that the end user is not sent duplicate messages and we can correctly respond to a PUBREL).

// The only message where we need to store the full body is outgoing QOS1/2. This is because those need to be resent
// following reconnection (subject to session state!). For all other messages we only need to know that the ID is in use
// and the type of message (ideally; this allows us to sanity check the response).
// We could store received QOS1/2 messages but the server will resend them anyway so this is not critical (in theory a
// quick resend of the ACK could save some bandwitdh but unlikely to be significant).

// Why integrate MIDs?
//
// The main reason is that the session state may outlast a single connection.
// When a new connection is established, the session state may (this depends upon clean start etc) still contain
// packet IDs from the previous connection (e.g. unacknowledged QOS1 publish). This leaves us with a choice of:
//   1. Reading from the store and creating a new MIDs.
//   2. Managing MIDs as part of the session state that outlasts a connection.
//
// Option 2 has a range of advantages:
//   * There is no need to read the store when reconnecting (potentially an expensive option if its on disk)
//   * Blocking calls to, for example, `Publish()` can remain blocked over a re-connect (providing better dev experience)
//   * Reduces the interactions between the store and the client (easy to introduce deadlocks etc here)
//   * MIDs can be populated when first needed rather than immediately (it may be expensive to load the data)
//
// Note re new MIDs design. The old MIDS used a slice (effectively `make([]*CPContext, 65535)`). This will consume
// approximately 500kb of ram (on a 64-bit machine); whilst this is not a lot on a PC it is significant on some lower
// resource devices on which this library may be used. In addition, most brokers now impose sensible defaults with
// mosquitto defaulting to "Receive Maximum" = 20. This means that allocating space for 65535 seems excessive. As a
// result we now use a map for this.

// Outstanding questions/TODO's
//
//   - How to deal with connecting to multiple brokers/changing the client id... (something for autopaho to sort out!)
//     currently we assume that we are connecting to a single broker.
//   - V5 supports "Topic Alias" but "A receiver MUST NOT carry forward any Topic Alias mappings from one Network Connection to another"
//     this creates an issue when a message is published with an alias and the connection drops before the message is
//     transmitted. I think we need to detect and cancel any message using an alias when the connection drops.
//   - The client should clear its session state after SessionExpiryInterval (don't see this as too much of an issue tho)
//   - How do we handle messages waiting their turn (e.g. blocked due to ReceiveMaximum). We should not allocate them an
//     ID until they are ready do be sent so really want to store them somewhere else (i.e. if in memory, in a slice).

var (
	ErrNoConnection = errors.New("no connection available")
)

// ErrorMidsExhausted is returned from Request() when there are no
// free message ids to be used.
var ErrorMidsExhausted = errors.New("all message ids in use")

const (
	midMin uint16 = 1
	midMax uint16 = 65535
)

type clientGenerated struct {
	packetType byte // The type of the request (i.e. PUBLISH, SUBSCRIBE or UNSUBSCRIBE) - 0 means unknown until loaded from the store
	subAckSent bool // True if we have sent a SUBACK (meaning local handler has completed)

	// When a message is fully acknowledged, we need to let the requester know by sending the final response to this
	// channel. One and only one message will be sent (the channel will then be closed to ensure this!).
	// We also guarantee to always send to the channel (assuming there is a clean shutdown) so that the end user knows
	// the status of the request.
	responseChan chan<- packets.ControlPacket

	//
	// The following relate to PUBLISH messages only
	//
	// qos            byte   // The QOS level (for PUBLISH packets)
	// lastPacketType byte   // The packet type we last sent (only relevant for QOS2 PUBLISH)

	// "A receiver MUST NOT carry forward any Topic Alias mappings from one Network Connection to another" this means
	// that we need to drop any outgoing messages that rely on a topic alias when the connection is lost. We should
	// probably cancel any messages waiting too (otherwise it gets hard to track!).
	// TODO: Think about how this should work!
	// alias bool // Does the message include an alias (these cannot survive connection loss)
}

// sessionState manages the session state. The client will send messages that may impact the state via
// us, and we will maintain the session state
type sessionState struct {
	mu                    sync.Mutex // protects whole struct (operations should be quick, so the impact of multiple mutexes is likely to be low)
	connectionLostAt      time.Time  // Time that the connection was lost
	sessionExpiryInterval uint32     // The session expiry interval sent with the most recent CONNECT packet

	connMu sync.Mutex
	conn   io.Writer

	// server store - holds packets where the message ID was generated on the server
	serverPackets map[uint16]byte // The last packet received from the server with this ID (cleared when the transaction is complete)
	serverStore   Storer          // Used to store session state that survives connection loss

	// client store - holds packets where the message ID was generated on the client (i.e. by paho.golang)
	clientPackets map[uint16]clientGenerated // Store relating to messages sent TO the server
	clientStore   Storer                     // Used to store session state that survives connection loss
	lastMid       uint16                     // The message ID most recently issued

	debug  Logger
	errors Logger
}

// Close closes the session state
func (s *sessionState) Close() error {
	s.mu.Lock()
	defer s.mu.Unlock()
	for packetID, cg := range s.clientPackets {
		cg.responseChan <- packets.ControlPacket{} // Default control packet indicates that we are shutting down (TODO: better solution?)
		delete(s.clientPackets, packetID)
	}
	return nil
}

// ConAckReceived will be called when the client receives a CONACK that indicates the connection has been successfully
// established. This indicates that a new connection is live and the passed in connection should be used going forward.
// It is also the trigger to resend any queued messages. Note that this function should not be called concurrently with
// others (we should not begin sending/receiving packets until after the CONACK has been processed).
// TODO: handle publish (send
// TODO: Which conn should we use? (always use the one here or take as parameter?)
func (s *sessionState) ConAckReceived(conn io.Writer, cp *packets.Connect, ca *packets.Connack) {
	// We could use cp.Properties.SessionExpiryInterval /  ca.Properties.SessionExpiryInterval to clear the session
	// after the specified time period (if the Session Expiry Interval is absent the value in the CONNECT Packet used)
	// however, this is not something the generic client can really accomplish (forks may wish to do this!).
	s.mu.Lock()
	defer s.mu.Unlock()
	s.conn = conn

	// If the server indicates that this is a cleansession we empty any saved session state
	if cp.CleanStart == true {
		s.clean()
	}

	// If the Server accepts a connection with Clean Start set to 1, the Server MUST set Session Present to 0 in the
	// CONNACK packet in addition to setting a 0x00 (Success) Reason Code in the CONNACK packet [MQTT-3.2.2-2].
	// If the Server accepts a connection with Clean Start set to 0 and the Server has Session State for the ClientID,
	// it MUST set Session Present to 1 in the CONNACK packet, otherwise it MUST set Session Present to 0 in the CONNACK
	// packet. In both cases it MUST set a 0x00 (Success) Reason Code in the CONNACK packet [MQTT-3.2.2-3].
	//
	// If the Session Expiry Interval is absent the value 0 is used. If it is set to 0, or is absent, the Session ends
	// when the Network Connection is closed (3.1.2.11.2).
	if ca.Properties != nil && ca.Properties.SessionExpiryInterval != nil {
		s.sessionExpiryInterval = *ca.Properties.SessionExpiryInterval
	} else {
		s.sessionExpiryInterval = 0
	}
}

// ConnectionLost will be called when the connection is lost; either because we received a DISCONNECT packet or due
// to a network error (`nil` will be passed in)
func (s *sessionState) ConnectionLost(dp *packets.Disconnect) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	if s.conn == nil {
		return nil // ConnectionLost may be called multiple times (but call ref Disconnect packet should be first)
	}
	s.conn = nil
	s.connectionLostAt = time.Now()

	if dp != nil && dp.Properties != nil && dp.Properties.SessionExpiryInterval != nil {
		s.sessionExpiryInterval = *dp.Properties.SessionExpiryInterval
	}
	// The Client and Server MUST store the Session State after the Network Connection is closed if the Session Expiry
	// Interval is greater than 0 [MQTT-3.1.2-23]
	if s.sessionExpiryInterval == 0 {
		s.clean()
	}
	return nil
}

// StartTransaction begins a client-initiated transaction (i.e. sends a request to which a response is expected).
// This function is responsible for assigning the Packet Identifier.
// If a nil error is returned, we guarantee that one, and only one, message will be sent to resp (assuming `Close()`
// is called).
func (s *sessionState) StartTransaction(packet packetWithID, resp chan<- packets.ControlPacket) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	if s.conn == nil {
		return ErrNoConnection
	}
	mid, err := s.allocateNextMid(packet.Type(), resp)
	if err != nil {
		return err
	}
	packet.SetIdentifier(mid)
	if _, err := packet.WriteTo(s.conn); err != nil {
		// Should we clear error in this case? Probably not as it should be in store
		return err
	}
	return nil
}

// endClientGenerated should be called when a client-generated transaction has been fully acknowledged
// (or if, due to connection loss, it will never be acknowledged).
func (s *sessionState) endClientGenerated(packetID uint16, recv *packets.ControlPacket) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	if cg, ok := s.clientPackets[packetID]; ok {
		cg.responseChan <- *recv
		delete(s.clientPackets, packetID)
		if err := s.clientStore.Delete(packetID); err != nil {
			s.errors.Printf("failed to remove message %d from store: %s", packetID, err)
		}
	} else {
		s.debug.Println("received a response for a message ID we don't know:", recv.PacketID())
	}
	return nil // TODO: Should we return errors here (not much that could be done with them)
}

// Ack is called when the client message handlers have completed (or, if manual acknowledgements are enabled, when
// `client.ACK()` has been called - this may happen some time after the message was received and it is conceivable that
// the connection may have been dropped and reestablished in the interim).
// See issue 160 re issues when the sessionState is called after the connection is dropped. We assume that the
// user will ensure that all ACK's are completed before the sessionState is applied to a new connection (not doing
// this may have unpredictable results).
func (s *sessionState) Ack(pb *packets.Publish) error {
	return s.ack(pb)
}

// ack sends an acknowledgment of the `PUBLISH` (which will have been received from the server)
// `s.mu` must NOT be locked when this is called.

// Note: Adding properties to the response is not currently supported. If this functionality is added, then it is
// important to note that QOS2 PUBREC's may be resent if a duplicate `PUBLISH` is received.
// This function will only return comms related errors (so caller can assume connection has been lost).
func (s *sessionState) ack(pb *packets.Publish) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	var err error
	switch pb.QoS {
	case 1:
		pa := packets.Puback{
			Properties: &packets.Properties{},
			PacketID:   pb.PacketID,
		}
		if s.conn != nil {
			s.debug.Println("sending PUBACK")
			_, err = pa.WriteTo(s.conn)
			if err != nil {
				s.errors.Printf("failed to send PUBACK for %d: %s", pb.PacketID, err)
			}
		} else {
			s.debug.Println("PUBACK not send because connection down")
		}
		// We don't store inbound QOS1 packets. This is because they will be retransmitted if the connection is
		// reestablished before the server reecives the ACK. Unfortunately there is no definitive way to determine if
		// such messages are duplicates or not (so we are forced to treat them all as if they are new).
	case 2:
		pr := packets.Pubrec{
			Properties: &packets.Properties{},
			PacketID:   pb.PacketID,
		}
		s.debug.Printf("sending PUBREC")
		_, err = pr.WriteTo(s.conn)
		if err != nil {
			s.errors.Printf("failed to send PUBREC for %d: %s", pb.PacketID, err)
		}

		// We need to record the fact that a PUBREC has been sent so we can detect receipt of a duplicate `PUBLISH`
		// (which should not be passed to the client app)
		cp := pr.ToControlPacket()
		s.serverStore.Put(cp)
		s.serverPackets[pb.PacketID] = cp.Type
	default:
		err = errors.New("ack called but publish not QOS 1 or 2")
	}
	return err
}

// PacketReceived should be called whenever one of the following is received:
// `PUBLISH` (QOS1+ only), `PUBACK`, `PUBREC`, `PUBREL`, `PUBCOMP`, `SUBACK`, `UNSUBACK`
// It will handle sending any neccessary response or passing the message to the client.
// pubChan will be sent a `PUBLISH` if applicable (and a receiver must be active whilst this function runs)
func (s *sessionState) PacketReceived(recv *packets.ControlPacket, pubChan chan<- *packets.Publish) error {
	// Note: we do a type switch rather than using the packet type because it's safer and easier to understand
	switch rp := recv.Content.(type) {
	//
	// Packets in response to client-generated transactions
	//
	case *packets.Suback: // Not in store, just need to advise client and free Message Identifier
		s.debug.Println("received SUBACK packet with id ", rp.PacketID)
		s.endClientGenerated(rp.PacketID, recv)
		return nil
	case *packets.Unsuback: // Not in store, just need to advise client and free Message Identifier
		s.debug.Println("received UNSUBACK packet with id ", rp.PacketID)
		s.endClientGenerated(rp.PacketID, recv)
		return nil
	case *packets.Puback: // QOS 1 initial (and final) response
		s.debug.Println("received PUBACK packet with id ", rp.PacketID)
		s.clientStore.Delete(rp.PacketID)
		s.endClientGenerated(rp.PacketID, recv)
		return nil
	case *packets.Pubrec: // Initial response to a QOS2 Publish
		s.debug.Println("received PUBREC packet with id ", rp.PacketID)
		s.mu.Lock()
		defer s.mu.Unlock()
		if cg, ok := s.clientPackets[rp.PacketID]; !ok {
			pl := packets.Pubrel{ // Respond with "Packet Identifier not found"
				PacketID:   recv.Content.(*packets.Pubrec).PacketID,
				ReasonCode: 0x92,
			}
			s.debug.Println("sending PUBREL (unknown ID) for ", pl.PacketID)
			_, err := pl.WriteTo(s.conn)
			if err != nil {
				s.errors.Printf("failed to send PUBREL for %d: %s", pl.PacketID, err)
			}
		} else {
			if rp.ReasonCode >= 0x80 {
				// Received a failure code (ending the transaction)
				cg.responseChan <- *recv
				delete(s.clientPackets, rp.PacketID)
				s.clientStore.Delete(rp.PacketID)
			} else {
				pl := packets.Pubrel{
					PacketID: rp.PacketID,
				}
				s.debug.Println("sending PUBREL for", rp.PacketID)
				_, err := pl.WriteTo(s.conn)
				if err != nil {
					s.errors.Printf("failed to send PUBREL for %d: %s", rp.PacketID, err)
				}
			}
		}
		return nil
	case *packets.Pubcomp: // QOS 2 final response
		s.debug.Printf("received PUBCOMP packet with id %d", rp.PacketID)
		s.clientStore.Delete(rp.PacketID)
		s.endClientGenerated(rp.PacketID, recv)
		return nil
		//
		// Packets relating to server generated PUBLISH
		//
	case *packets.Publish:
		s.debug.Printf("received QoS%d PUBLISH", rp.QoS)
		// There is no need to store the packet because it will be resent if not acknowledged before the connection is
		// reestablished.
		if rp.QoS > 0 {
			if rp.PacketID == 0 { // Invalid
				return fmt.Errorf("received QOS %d PUBLISH with 0 PacketID", rp.QoS)
			}
			if rp.QoS == 2 {
				s.mu.Lock()
				defer s.mu.Unlock()
				if lastSent, ok := s.serverPackets[rp.PacketID]; ok {
					// If we have sent a PUBREC, that means that the client has already seen this message, so we can
					// simply resend the acknowledgment.
					if lastSent == packets.PUBREC {
						// If the message is not flagged as a duplicate, then something is wrong; to avoid message loss,
						// we will treat this as a new message (because it appears there is a session mismatch, and we
						// have not actually seen this message).
						if rp.Duplicate {
							// The client has already seen this message meaning we do not want to resend it and, instead
							// immediately acknowledge it.
							s.mu.Unlock() // mu must be unlocked to call ack
							return s.ack(rp)
						}
						s.errors.Printf("received duplicate PUBLISH (%d) but dup flag not set (will assume this overwrites old publish)", rp.PacketID)
					} else {
						s.errors.Printf("received PUBLISH (%d) but lastSent type is %d (unexpected!)", lastSent)
					}
				}
			}
		}
		pubChan <- rp // the message will be passed to router (and thus the end user app)
		return nil
	case *packets.Pubrel:
		s.debug.Println("received PUBREL for", recv.PacketID())
		// Auto respond to pubrels unless failure code
		pr := recv.Content.(*packets.Pubrel)
		if pr.ReasonCode >= 0x80 {
			// Received a failure code meaning the server does not know about the message (so all we can do is to remove
			// it from our store).
			s.errors.Printf("received PUBREL with reason code %d ", pr.ReasonCode)
			return nil
		} else {
			pc := packets.Pubcomp{
				PacketID: pr.PacketID,
			}
			s.mu.Lock()
			defer s.mu.Unlock()
			s.debug.Println("sending PUBCOMP for", pr.PacketID)
			var err error
			if s.conn != nil {
				_, err = pc.WriteTo(s.conn)
				if err != nil {
					s.errors.Printf("failed to send PUBCOMP for %d: %s", pc.PacketID, err)
				}
				// Note: If connection is down we do not clear store (because the server will resend PUBREL upon reconnect)
				delete(s.serverPackets, pr.PacketID)
				if sErr := s.serverStore.Delete(pr.PacketID); sErr != nil {
					s.errors.Printf("failed to remove message %d from server store: %s", pr.PacketID, sErr)
				}
			}
			return err
		}
	default:
		s.errors.Printf("sessionState.PacketReceived received unexpected packet: %#v ", rp)
		return nil
	}
}

// allocateNextMid assigns the next available MID
// Callers must hold lock on s.mu
func (s *sessionState) allocateNextMid(forPacketType byte, resp chan<- packets.ControlPacket) (uint16, error) {
	cg := clientGenerated{
		packetType:   forPacketType,
		responseChan: resp,
	}

	// Scan from lastMid to end of range.
	for i := s.lastMid + 1; i != 0; i++ {
		if _, ok := s.clientPackets[i]; ok {
			continue
		}
		s.clientPackets[i] = cg
		s.lastMid = i
		return i, nil
	}

	// Default struct will set s.lastMid=0 meaning we have already scanned all mids
	if s.lastMid == 0 {
		s.lastMid = 1
		return 0, ErrorMidsExhausted
	}

	// Scan from start of range to lastMid (use +1 to avoid rolling over when s.lastMid = 65535)
	for i := uint16(0); i < s.lastMid; i++ {
		if _, ok := s.clientPackets[i+1]; ok {
			continue
		}
		s.clientPackets[i+1] = cg
		s.lastMid = i + 1
		return i + 1, nil
	}
	return 0, ErrorMidsExhausted
}

// clean deletes any existing stored session information
// caller is responsible for locking s.mu
func (s *sessionState) clean() {
	s.debug.Println("sessionState.clean() called")
	s.serverPackets = make(map[uint16]byte)

	for _, p := range s.clientPackets {
		p.responseChan <- packets.ControlPacket{}
	}
	s.clientPackets = make(map[uint16]clientGenerated)

	s.serverStore.Reset()
	s.clientStore.Reset()
}

// clean deletes any existing stored session information
// as per section 4.1 in the spec; The Session State in the Client consists of:
// > · QoS 1 and QoS 2 messages which have been sent to the Server, but have not been completely acknowledged.
// > · QoS 2 messages which have been received from the Server, but have not been completely acknowledged.
// This means that we keep PUBLISH, PUBREC and PUBREL packets. PUBACK and PUBCOMP will not be stored (the MID
// will be free once they have been sent). PUBREC is retained so we can check newly received PUBLISH messages (and
// confirm if they have already been processed).
// We only resend PUBLISH (where QoS > 0) and PUBREL packets (as per spec section 4.4)
// caller is responsible for locking s.mu
func (s *sessionState) tidy(trigger *packets.ControlPacket) {
	s.debug.Println("sessionState.tidy() called")
	for id, p := range s.serverPackets {
		switch p {
		case packets.PUBREC:
			// For inbound messages, we only retain `PUBREC` messages so that we can determine if a PUBLISH received has
			// already been processed (the `PUBREL` will be sent when the message has been processed by our user).
			// The broker will resend any `PUBLISH` and `PUBREL` messages, so there is no need to retain those.
		default:
			delete(s.serverPackets, id)
			s.serverStore.Delete(id)
		}
	}

	for id, p := range s.clientPackets {
		// We only need to remember `PUBLISH` and `PUBREL` messages (both originating from a PUBLISH)
		if p.packetType != packets.PUBLISH {
			delete(s.clientPackets, id)
			s.clientStore.Delete(id)
			p.responseChan <- packets.ControlPacket{}
		}
	}
}
